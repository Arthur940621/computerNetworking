# `TCP/IP` 网络编程

## 第一章: 理解网络编程和套接字

### 理解网络编程和套接字

网络编程就是编写程序使两台连网的计算机相互交换数据。网络编程又称为套接字编程。

套接字大致分为两种，其中，`TCP` 套接字可以比喻成电话机。电话机也是通过固定电话网完成语音数据交换的。因此，我们熟悉的固定电话与套接字实际并无太大区别。

#### 构建接电话套接字

下面利用电话机讲解套接字的创建及使用方法。电话机可以同时用来拨打或接听，但对套接字而言，拨打和接听是有区别的。我们先讨论用于接听的套接字创建过程。

调用 `socket` 函数（安装电话机）时进行的对话:
- 问: 接电话需要准备什么？
- 答: 当然是电话机！

有了电话机才能安装电话，接下来，我们就准备一部的电话机。下列函数创建的就是相当于电话机的套接字。

```c
#include <sys/socket.h>
int socket(int domain, int type, int protocol);
// 成功时返回文件描述符，失败时返回 -1。
```

我们只需购买机器，剩下的安装和分配电话号码等工作都由电信局的工作人员完成。

准备好电话机后要考虑分配电话号码的问题，这样别人才能联系到自己。

调用 `bind` 函数（分配电话号码）时进行的对话:
- 问: 请问您的电话号码是多少？
- 答: 我的电话号码是 `123-1234`。

套接字同样如此。就像给电话机分配电话号码一样（虽然不是真的把电话号码给了电话机），利用以下函数给创建好的套接字分配地址信息（`IP` 地址和端口号）。

```c
#include <sys/socket.h>
int bind(int sockfd, struct sockaddr* myaddr, socklen_t addrlen);
// 成功时返回 0，失败时返回 -1。
```

调用 `bind` 函数给套接字分配地址后，就基本完成了接电话的所有准备工作。接下来需要连接电话线并等待来电。

调用 `listen` 函数（连接电话线）时进行的对话
- 问: 已架设完电话机后是否只需连接电话线？
- 答: 对，只需连接就能接听电话。

一连接电话线，电话机就转为可接听状态，这时其他人可以拨打电话请求连接到该机。同样，需要把套接字转化成可接收连接的状态。

```c
#include <sys/socket.h>
int listen(int sockfd, int backlog);
//成功时返回 0，失败时返回 -1。
```

连接好电话线后，如果有人拨打电话就会响铃，拿起话筒才能接听电话。

调用 `accept` 函数（拿起话筒）时进行的对话
- 问: 电话铃响了，我该怎么办？
- 答: 难道您真不知道？接听啊！

拿起话筒意味着接收了对方的连接请求。套接字同样如此，如果有人为了完成数据传输而请求连接，就需要调用以下函数进行受理。

```c
#include <sys/socket.h>
int accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen);
// 成功时返回文件描述符，失败时返回 -1。
```

网络编程中接受连接请求的套接字创建过程可整理如下:
- 第一步: 调用 `socket` 函数创建套接字。
- 第二步: 调用 `bind` 函数分配 `IP` 地址和端口号。
- 第三步: 调用 `listen` 函数转为可接收请求状态。
- 第四步: 调用 `accept` 函数受理连接请求。

[hello_server](./src/chapter1/hello_server.cpp)

#### 构建打电话套接字

客户端套接字是用于请求连接的套接字。

打电话（请求连接）的函数，其调用的是客户端套接字，如下所示。

```c
#include <sys/socket.h>
int connect(int sockfd, struct sockaddr* serv_addr, socklen_t addrlen);
// 成功时返回 0，失败时返回 -1。
```

客户端程序只有调用 `socket` 函数创建套接字和调用 `connect` 函数向服务器端发送连接请求这两个步骤，因此比服务器端简单。

[hello_client](./src/chapter1/hello_client.cpp)

### 基于 Linux 的文件操作

对 `Linux` 而言，`socket` 也被认为是文件的一种，`socket` 操作与文件操作没有区别，因此在网络数据传输过程中自然可以使用文件 `I/O` 的相关函数。

分配给标准输入输出及标准错误的文件描述符:

|文件描述符|对象|
|-|-|
|0|标准输入: Standard Input|
|1|标准输出: Standard Output|
|2|标准错误: Standard Error|

文件和套接字一般经过创建过程才会被分配文件描述符。而表中的 `3` 种输入输出对象即使未经过特殊的创建过程，程序开始运行后也会被自动分配文件描述符。

#### 打开文件

首先介绍打开文件以读写数据的函数。调用此函数时需传递两个参数: 第一个参数是打开的目标文件名及路径信息，第二个参数是文件打开模式。

![001](./Image/socket/001.png)

下表是此函数第二个参数 `flag` 可能的常量值及含义。如需传递多个参数，则应通过位或运算符组合并传递。

|打开模式|含义|
|-|-|
|O_CREAT|必要时创建文件|
|O_TRUNC|删除全部现有数据|
|O_APPEND|维持现有数据，保存到其后面|
|O_RDONLY|只读打开|
|O_WRONLY|只写打开|
|O_RDWR|读写打开|

#### 关闭文件

使用文件后必须关闭。

![002](./Image/socket/002.png)

此函数不仅可以关闭文件，还可以关闭套接字。

#### 将数据写入文件

`write` 函数用于向文件输出（传输）数据。

![003](./Image/socket/003.png)

此函数定义中，`size_t` 是通过 `typedef` 声明的 `unsigned int` 类型。对 `ssize_t` `来说，size_t` 前面多加的 `s` 代表 `signed`，即 `ssize_t` 是通过 `typedef` 声明的 `signed int` 类型。

[low_open](./src/chapter1/low_open.cpp)

#### 读取数据中的文件

与之前的 `write` 函数相对应，`read` 函数用来输入（接收）数据。

![004](./Image/socket/004.png)

[low_read](./src/chapter1/low_read.cpp)

## 第二章: 套接字类型与与协议设置

### 套接字协议以及其数据传输特性

#### 关于协议

如果相隔很远的两人想展开对话，必须先决定对话方式。如果一方使用电话，那么另一方也只能使用电话，而不是书信。可以说，电话就是两人对话的协议。

协议是对话中使用的通信规则，把上述概念拓展到计算机领域可整理为计算机间对话必备通信规则。

简言之，协议就是为了完成数据交换而定好的约定。

#### 创建套接字

![005](./Image/socket/005.png)

#### 协议簇

奶油意大利面和番茄酱意大利面均属于意大利面的一种，与之类似，套接字通信中的协议也具有一些分类。通过 `socket` 函数的第一个参数传递套接字中使用的协议分类信息。此协议分类信息称为协议族，声明在头文件 `<sys/socket.h>` 中，可分成如下几类:

|名称|协议族|
|-|-|
|PF_INET|IPv4 互联网协议族|
|PF_INET6|IPv6 互联网协议族|
|PF_LOCAL|本地通信的 UNIX 协议族|
|PF_PACKET|底层套接字的协议族|
|PF_IPX|IPX Novell 协议族|

我们主要学习 `PF_INET` 对应的 `IPv4` 互联网协议族，其他协议族并不常用或尚未普及。

另外，套接字中实际采用的最终协议信息是通过 `socket` 函数的第三个参数传递的。在指定的协议族范围内通过第一个参数决定第三个参数。

#### 套接字类型

套接字类型指的是套接字的数据传输方式，通过 `socket` 函数的第二个参数传递，只有这样才能决定创建的套接字的数据传输方式。

决定了协议族并不能同时决定数据传输方式，换言之，`socket` 函数第一个参数 `PF_INET` 协议族中也存在多种数据传输方式。

下面介绍 `2` 种具有代表性的数据传输方式。

#### 面向连接的套接字（`SOCK_STREAM`）

如果向 `socket` 函数的第二个参数传递SOCK_STREAM，将创建面向连接的套接字。

![006](./Image/socket/006.png)

图中 `2` 位工人通过 `1` 条传送带传递物品，这与面向连接的数据传输方式类似。

数据（糖果）传输方式特征整理如下:
- 传输过程中数据不会消失。
- 按序传输数据。
- 传输的数据不存在数据边界。

图中通过独立的传送带传输数据（糖果），只要传送带本身没有问题，就能保证数据不丢失。

同时，较晚传递的数据不会先到达，因为传送带保证了数据的按序传递。最后，下面这句话说明的确不存在数据边界:

**`100` 个糖果是分批传递的，但接收者凑齐 `100` 个后才装袋。**

这种情形可以适用到之前说过的 `write` 和 `read` 函数。

传输数据的计算机通过 `3` 次调用 `write` 函数传递了 `100` 字节的数据，但接收数据的计算机仅通过 `1` 次 `read` 函数调用就接收了全部 `100` 个字节。

收发数据的套接字内部有缓冲（`buffer`） ，简言之就是字节数组。通过套接字传输的数据将保存到该数组。因此，收到数据并不意味着马上调用 `read` 函数。只要不超过数组容量，则有可能在数据填充满缓冲后通过 `1` 次 `read` 函数调用读取全部，也有可能分成多次 `read` 函数调用进行读取。也就是说，在面向连接的套接字中，`read` 函数和 `write` 函数的调用次数并无太大意义。所以说面向连接的套接字不存在数据边界。

如果缓冲被接收的数据填满会发生什么事情？之后传递的数据是否会丢失？

首先调用 `read` 函数从缓冲读取部分数据，因此，缓冲并不总是满的。但如果 `read` 函数读取速度比接收数据的速度慢，则缓冲有可能被填满。此时套接字无法再接收数据，但即使这样也不会发生数据丢失，因为传输端套接字将停止传输。也就是说，面向连接的套接字会根据接收端的状态传输数据，如果传输出错还会提供重传服务。因此，面向连接的套接字除特殊情况外不会发生数据丢失。

还有一点需要说明。上图中传输和接收端各有 `1` 名工人，这说明面向连接的套接字还有如下特点:

**套接字连接必须一一对应。**

面向连接的套接字只能与另外一个同样特性的套接字连接。用一句话概括面向连接的套接字如下:

**可靠的、按序传递的、基于字节的面向连接的数据传输方式的套接字。**

#### 面向消息的套接字（`SOCK_DGRAM`）

如果向 `socket` 函数的第二个参数传递 `SOCK_DGRAM` ，则将创建面向消息的套接字。

![007](./Image/socket/007.png)

面向消息的套接字可以比喻成高速移动的摩托车快递。图中摩托车快递的包裹（数据）传输方式如下:
- 强调快速传输而非传输顺序。
- 传输的数据可能丢失也可能损毁。
- 传输的数据有数据边界。
- 限制每次传输的数据大小。

众所周知，快递行业的速度就是生命。用摩托车发往同一目的地的 `2` 件包裹无需保证顺序，只要以最快速度交给客户即可。这种方式存在损坏或丢失的风险，而且包裹大小有一定限制。因此，若要传递大量包裹，则需分批发送。另外，如果用 `2` 辆摩托车分别发送 `2` 件包裹，则接收者也需要分 `2` 次接收。这种特性就是传输的数据具有数据边界。

以上就是面向消息的套接字具有的特性。即，面向消息的套接字比面向连接的套接字具有更快的传输速度，但无法避免数据丢失或损毁。另外，每次传输的数据大小具有一定限制，并存在数据边界。存在数据边界意味着接收数据的次数应和传输次数相同。面向消息的套接字特性总结如下:

**不可靠的、不按序传递的、以数据的高速传输为目的的套接字。**

另外，面向消息的套接字不存在连接的概念。

#### 协议的最终选择

前面已经通过 `socket` 函数的前两个参数传递了协议族信息和套接字数据传输方式，这些信息还不足以决定采用的协议吗？为什么还需要传递第 `3` 个参数呢？

传递前两个参数即可创建所需套接字。所以大部分情况下可以向第三个参数传递 `0`，除非遇到以下这种情况:

同一协议族中存在多个数据传输方式相同的协议。

数据传输方式相同，但协议不同。此时需要通过第三个参数具体指定协议信息。

`IPv4` 协议族中面向连接的套接字:

参数 `PF_INET` 指 `IPv4` `网络协议族，SOCK_STREAM` 是面向连接的数据传输。满足这 `2` 个条件的协议只有 `IPPROTO_TCP`，因此可以如下调用 `socket` 函数创建套接字，这种套接字称为 `TCP` 套接字:

```c
int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
```

`IPv4` 协议族中面向消息的套接字:

`SOCK_DGRAM` 指的是面向消息的数据传输方式，满足上述条件的协议只有 `IPPROTO_UDP`。

因此，可以如下调用 `socket` 函数创建套接字，这种套接字称为 `UDP` 套接字:

```c
int udp_socket = socket(PF_INET, SOCK_DGRAM, IP PROTO_UDP);
```

#### `TCP` 套接字示例

`TCP` 套接字的如下特性:

**传输的数据不存在数据边界。**

为验证这一点，需要让 `write` 函数的调用次数不同于 `read` 函数的调用次数。因此，在客户端中分多次调用 `read` 函数以接收服务器端发送的全部数据。

[tcp_client](./src/chapter2/tcp_client.cpp)

## 第三章: 地址族与数据序列

### 分配给套接字的 `IP` 地址与端口号

`IP` 是 `Internet Protocol`（网络协议）的简写，是为收发网络数据而分配给计算机的值。

端口号并非赋予计算机的值，而是为区分程序中创建的套接字而分配给套接字的序号。

#### 网络地址

为使计算机连接到网络并收发数据，必需向其分配 `IP` 地址。`IP` 地址分为两类。

- `IPv4`（`Internet Protocol version4`）`4` 字节地址族
- `IPv6`（`Internet Protocol version 6`）`16` 字节地址族

#### 用于区分套接字的端口号

`IP` 用于区分计算机，只要有 `IP` 地址就能向目标主机传输数据，但仅凭这些无法传输给最终的应用程序。假设我们欣赏视频的同时在网上冲浪，这时至少需要 `1` 个接收视频数据的套接字和 `1` 个接收网页信息的套接字。问题在于如何区分二者。简言之，传输到计算机的网络数据是发给播放器，还是发送给浏览器？

计算机中一般配有 `NIC`（`Network Interface Card`，网络接口卡）数据传输设备。通过 `NIC` 向计算机内部传输数据时会用到 `IP`。操作系统负责把传递到内部的数据适当分配给套接字，这时就要利用端口号。也就是说，通过 `NIC` 接收的数据内有端口号，操作系统正是参考此端口号把数据传输给相应端口的套接字。

端口号就是在同一操作系统内为区分不同套接字而设置的，因此无法将 `1` 个端口号分配给不同套接字。另外，端口号由 `16` 位构成，可分配的端口号范围是 `0-65535`。

虽然端口号不能重复，但 `TCP` 套接字和 `UDP` 套接字不会共用端口号，所以允许重复。例如: 如果某 `TCP` 套接字使用 `9190` 号端口，则其他 `TCP` 套接字就无法使用该端口号，但 `UDP` 套接字可以使用。

总之，数据传输目标地址同时包含 `IP` 地址和端口号，只有这样，数据才会被传输到最终的目的应用程序。

### 地址信息的表示

结构体定义为如下形态，此结构体将作为地址信息传递给 `bind` 函数。

![008](./Image/socket/008.png)

该结构体中提到的另一个结构体 `in_addr` 定义如下，它用来存放 `32` 位 `IP` 地址。

![009](./Image/socket/009.png)

数据类型的定义:

![010](./Image/socket/010.png)

#### 结构体 `sockaddr_in` 的成员分析

- `sin_family`
  - 每种协议族适用的地址族均不同。比如，`IPv4` 使用 `4` 字节地址族，`IPv6` 使用 `16` 字节地址族。
  - ![011](./Image/socket/011.png)
  - 在 `socket` 编程中只能是 `AF_INET`。
- `sin_port`
  - 该成员保存 `16` 位端口号，它以网络字节序保存。
- `sin_addr`
  - 该成员保存 `32` 位 `IP` 地址信息，且也以网络字节序保存。
  - `sin_addr` 的类型为结构体 `in_addr`，其成员 `s_addr` 为 `In_addr_t` 类型，声明为 `uint32_t`，当作 `32` 位整数型即可。
- `sin_zero`。
  - 无特殊含义。只是为使结构体 `sockaddr_in` 的大小与 `sockaddr` 结构体保持一致而插入的成员。必需填充为 `0`，否则无法得到想要的结果。

`bind` 函数的第二个参数期望得到 `sockaddr` 结构体变量地址值，包括地址族、端口号、`IP` 地址等。但是直接向 `sockaddr` 结构体填充这些信息会带来麻烦。

![012](./Image/socket/012.png)

此结构体成员 `sa_data` 保存的地址信息中需包含 `IP` 地址和端口号，剩余部分应填充 `0`。而这对于包含地址信息来讲非常麻烦，继而就有了新的结构体`sockaddr_in`。

为何会使用两个数据结构 `sockaddr` 和 `sockaddr_in` 来表示地址，原因是如 `sa_family` 所指出的，`socket` 设计之初本来就是准备支持多个地址协议的。不同的地址协议由自己不同的地址构造，譬如对于 `IPv4` 就是 `sockaddr_in`，`IPV6` 就是 `sockaddr_in6`，以及对于 `AF_UNIX` 就是 `sockaddr_un`。

`sockaddr` 是对这些地址的上一层的抽象。另外，像 `sockaddr_in` 将地址拆分为 `port` 和 `IP`，对编程也更友好。这样，在将所使用的的值赋值给 `sockaddr_in` 数据结构之后，通过强制类型转换，就可以转换为 `sockaddr`。当然，从 `sockaddr` 也可以强制类型转换为 `sockaddr_in`。


### 网络字节序与地址变换

不同 `CPU` 中，`4` 字节整数型值 `1` 在内存空间的保存方式是不同的。`4` 字节整数型值 `1` 可用 `2` 进制表示如下。

`00000000 00000000 00000000 00000001`

有些 `CPU` 以这种顺序保存到内存，另外一些 `CPU` 则以倒序保存。

`00000001 00000000 00000000 00000000`

若不考虑这些就收发数据则会发生问题，因为保存顺序的不同意味着对接收数据的解析顺序也不同。

#### 字节序与网络字节序

`CPU` 向内存保存数据的方式有 `2` 种，这意味着 `CPU` 解析数据的方式也分为 `2` 种:
- 大端序（`Big Endian`）: 高位字节存放到低位地址。
- 小端序（`Little Endian`）: 高位字节存放到高位地址。

示例，假设在 `0x20` 号开始的地址中保存 `4` 字节 `int` 类型数 `0x12345678`。大端序 `CPU` 保存方式如图所示。

![013](./Image/socket/013.png)

整数 `0x12345678` 中，`0x12` 是最高位字节，`0x78` 是最低位字节。因此，大端序中先保存最高位字节 `0x12`（最高位字节 `0x12` 存放到低位地址）。

小端序保存如图所示。

![014](./Image/socket/014.png)

先保存的是最低位字节 `0x78`。目前主流的 `Intel` 系列 `CPU` 以小端序方式保存数据。

网络传输数据时约定统一方式，这种约定称为网络字节序，统一为大端序。

小端传输系统传输数据时应转换为大端序列排序方式。

#### 字节序转换

```C
unsigned short htons(unsigned short);
unsigned short ntohs(unsigned short);
unsigned long htonl(unsigned long);
unsigned long ntohl(unsigned long);
```

- `h` 代表主机字节序，`n` 代表网络字节序。
- `s` 指的是 `short`，`l` 指的是 `long`（`Linux` 中 `long` 类型占用 `4` 个字节（`32` 位））。

[endian_conv](./src/chapter3/endian_conv.cpp)

数据转换成网络字节序这个过程是自动的。除了向 `sockaddr_in` 结构体变量填充数据外，其他情况无需考虑字节序问题。

#### 将字符信息转换为网络字节序的整数型

对于 `IP` 地址的表示，我们熟悉的是点分十进制表示法，而非整数型数据表示法。

![015](./Image/socket/015.png)

[inet_addr](./src/chapter3/inet_addr.cpp)

`inet_aton` 函数与 `inet_addr` 函数在功能上完全相同，也将字符串形式 `IP` 地址转换为 `32` 位网络字节序整数并返回。只不过该函数利用了 `in_addr` 结构体，且其使用频率更高。

![016](./Image/socket/016.png)

[inet_addr](./src/chapter3/inet_addr.cpp)

`inet_ntoa` 函数正好相反，此函数可以把网络字节序整数型 `IP` 地址转换成我们熟悉的字符串形式。

![017](./Image/socket/017.png)

返回字符串地址意味着字符串已保存到内存空间，但该函数未向程序员要求分配内存，而是在内部申请了内存并保存了字符串。也就是说，调用完该函数后，应立即将字符串信息复制到其他内存空间。因为，若再次调用该函数，则有可能覆盖之前保存的字符串信息。

[inet_ntoa](./src/chapter3/inet_ntoa.cpp)

#### 网络地址初始化

```c
struct sockaddr_in addr;
char* serv_ip = "211.217.168.13"; // 声明 IP 地址字符串
char* serv_port = "9190"; // 声明端口号字符串
memset(&addr, 0, sizeof(addr)); // 结构体变量 addr 的所有成员初始化为 0
addr.sin_family = AF_INET; // 指定地址族
addr.sin_addr.s_addr = inet_addr(serv_ip); // 基于字符串的IP地址初始化
addr.sin_port = htons(atoi(serv_port)); // 基于字符串的端口号初始化
```

`memset` 函数将每个字节初始化为同一值，第一个参数为结构体变量 `addr` 的地址值，即初始化对象为 `addr`，第二个参数为 `0`，因此初始化为 `0`，最后一个参数中传入addr的长度，因此 `addr` 的所有字节均初始化为 `0`。这么做是为了将 `sockaddr_in` 结构体的成员 `sin_zero` 初始化为 `0`。

#### 客户端地址初始化

上述网络地址信息初始化过程主要针对服务器端而非客户端。服务器端的准备工作通过 `bind` 函数完成，而客户端则通过 `connect` 函数完成。

因此函数调用前需准备的地址值类型也不同。服务器端声明 `sockaddr_in` 结构体变量，将其初始化为赋予服务器端 `IP` 和套接字的端口号，然后调用 `bind` 函数，而客户端则声明 `sockaddr_in` 结构体，并初始化为要与之连接的服务器端套接字的 `IP` 和端口号，然后调用 `connect` 函数。

#### `INADDR_ANY`

利用常数 `INADDR_ANY` 分配服务器端的 `IP` 地址，可自动获取运行服务器端的计算机 `IP` 地址，不必亲自输入。而且，若同一计算机中已分配多个 `IP` 地址计算机，则只要端口号一致，就可以从不同 `IP` 地址接收数据。因此，服务器端中优先考虑这种方式。而客户端中除非带有一部分服务器端功能，否则不会采用。

#### 向套接字分配网络

![018](./Image/socket/018.png)

如果此函数调用成功，则将第二个参数指定的地址信息分配给第一个参数中的相应套接字。

## 第四章: 基于 `TCP` 的服务器端/客户端（`1`）

### 理解 `TCP` 和 `UDP`

#### `TCP/IP` 协议栈

![019](./Image/socket/019.png)

`TCP/IP` 协议栈共分 `4` 层，可以理解为数据收发分成了 `4` 个层次化过程。也就是说，面对基于互联网的有效数据传输的命题，并非通过 `1` 个庞大协议解决问题，而是化整为零，通过层次化方案，`TCP/IP` 协议栈解决。

各层可能通过操作系统等软件实现，也可能通过类似 `NIC` 的硬件设备实现。

#### 链路层

链路层是物理链接领域标准化的结果，也是最基本的领域，专门定义 `LAN`、`WAN`、`MAN` 等网络标准。若两台主机通过网络进行数据交换，则需要物理连接，链路层就负责这些标准。

#### `IP` 层

准备好物理连接后就要传输数据。为了在复杂的网络中传输数据，首先需要考虑路径的选择。解决此问题就是 `IP` 层，该层使用的协议就是 `IP`。

`IP` 本身是面向消息的、不可靠的协议。每次传输数据时会帮我们选择路径，但并不一致。如果传输中发生路径错误，则选择其他路径。但如果发生数据丢失或错误，则无法解决。换言之，`IP` 协议无法应对数据错误。

#### `TCP/UDP` 层

`TCP` 和 `UDP` 层以 `IP` 层提供的路径信息为基础完成实际的数据传输，故该层又称传输层。

`UDP` 比 `TCP` 简单，`TCP` 可以保证可靠的数据传输，但它发送数据时以 `IP` 层为基础。

`IP` 层只关注 `1` 个数据包的传输过程。因此，即使传输多个数据包，每个数据包也是由 `IP` 层实际传输的，也就是说传输顺序及传输本身是不可靠的。若只利用 `IP` 层传输数据，则有可能导致后传输的数据包 `B` 比先传输的数据包 `A` 提早到达。另外，传输的数据包 `A`、`B`、`C` 中有可能只收到 `A` 和 `C`，甚至收到的 `C` 可能已损毁。

若添加 `TCP` 协议，如果数据交换过程中可以确认对方已收到数据，并重传丢失的数据，那
么即便 `IP` 层不保证数据传输，这类通信也是可靠的。

总之，`TCP` 和 `UDP` 存在于 `IP` 层之上，决定主机之间的数据传输方式，`TCP` 协议确认后向不可靠的 `IP` 协议赋予可靠性。


#### 应用层

上述内容是套接字通信过程中自动处理的。选择数据传输路径、数据确认过程都被隐藏到套接字内部。

编写软件的过程中，需要根据程序特点决定服务器端和客户端之间的数据传输规则，这便是应用层协议。网络编程的大部分内容就是设计并实现应用层协议。

### 实现基于 `TCP` 的服务器端/客户端

#### `TCP` 服务器端的默认函数调用顺序

![020](./Image/socket/020.png)

#### 进入等待连接请求状态

我们已调用 `bind` 函数给套接字分配了地址，接下来就要通过调用 `listen` 函数进入等待连接请求状态。这时客户端才能调用 `connect` 函数。

![021](./Image/socket/021.png)

服务器端处于等待连接请求状态是指，客户端请求连接时，受理连接前一直使请求处于等待状态。

![022](./Image/socket/022.png)

客户端连接请求本身也是从网络中接收到的一种数据，而要想接收就需要套接字。此任务就由服务器端套接字完成。服务器端套接字是接收连接请求的一名门卫或一扇门。

`listen` 函数的第二个参数决定了等候室的大小。等候室称为连接请求等待队列，准备好服务器端套接字和连接请求等待队列后，这种可接收连接请求的状态称为等待连接请求状态。

`listen` 函数的第二个参数值与服务器端的特性有关，像频繁接收请求的 `Web` 服务器端至少应为 `15`。另外，连接请求队列的大小始终根据实验结果而定。

#### 受理客户端连接请求

调用 listen 函数后，若有新的连接请求，则应按序受理。受理请求意味着进入可接受数据的状态。

![023](./Image/socket/023.png)

`accept` 函数受理连接请求等待队列中待处理的客户端连接请求。函数调用成功时，`accept` 函数内部将产生用于数据 `I/O` 的套接字，并返回其文件描述符。套接字是自动创建的，并自动与发起连接请求的客户端建立连接。

#### `TCP` 客户端的默认函数调用顺序

![024](./Image/socket/024.png)

服务器端调用 listen 函数后创建连接请求等待队列，之后客户端即可请求连接。

![025](./Image/socket/025.png)

客户端调用 connect 函数后，发生以下情况之一才会返回（完成函数调用）:
- 服务器端接收连接请求。
- 发生断网等异常情况而中断连接请求。

需要注意，所谓的接收连接并不意味着服务器端调用 `accept` 函数，其实是服务器端把连接请求信息记录到等待队列。因此 `connect` 函数返回后并不立即进行数据交换。

客户端的 `IP` 地址和端口在调用 `connect` 函数时自动分配，无需调用标记的 `bind` 函数进行分配。

#### 基于 TCP 的服务器端/客户端函数调用关系

![026](./Image/socket/026.png)

服务器端创建套接字后连续调用 `bind`、`listen` 函数进入等待状态，客户端通过调用 `connect` 函数发起连接请求。需要注意的是，客户端只能等到服务器端调用 `listen` 函数后才能调 `connect` 函数。同时要清楚，客户端调用 `connect` 函数前，服务器端有可能率先调用 `accept` 函数。当然，此时服务器端在调用 `accept` 函数时进入阻塞状态，直到客户端调 `connect` 函数为止。

### 实现迭代服务器端/客户端

服务器端将客户端传输的字符串数据原封不动地传回客户端，就像回声一样。

之前讨论的 `Helloworld` 服务器端处理完 `1` 个客户端连接请求即退出，连接请求等待队列实际没有太大意义。但这并非我们想象的服务器端。设置好等待队列的大小后，应向所有客户端提供服务，继续受理后续的客户端连接请求。

![027](./Image/socket/027.png)

调用 `accept` 函数后，紧接着调用 `I/O` 相关的 `read`、`write` 函数，然后调用 `close` 函数。这并非针对服务器端套接字，而是针对 `accept` 函数调用时创建的套接字。

调用 `close` 函数就意味着结束了针对某一客户端的服务。此时如果还想服务于其他客户端，就要重新调用 `accept` 函数。

- 服务器端在同一时刻只与一个客户端相连，并提供回声服务。
- 服务器端依次向 `5` 个客户端提供服务并退出。
- 客户端接收用户输入的字符串并发送到服务器端。
- 服务器端将接收的字符串数据传回客户端，即回声。
- 服务器端与客户端之间的字符串回声一直执行到客户端输入 `Q` 为止。

[echo_server](./Image/../src/chapter4/echo_server.cpp)

[echo_client](./Image/../src/chapter4/echo_client.cpp)

#### 回声客户端存在的问题

下列是 `echo_client.cpp` 中的代码:

```cpp
write(sock, message, strlen(message));
str_len = read(sock, message, BUF_SIZE - 1);
message[str_len] =0;
```

以上代码有个错误假设:

每次调用 `read`、`write` 函数时都会以字符串为单位执行实际的 `I/O` 操作。

当然，每次调用 `write` 函数都会传递 `1` 个字符串，因此这种假设在某种程度上也算合理。

但 `TCP` 不存在数据边界。上述客户端是基于 `TCP` 的，因此，多次调用 `write` 函数传递的字符串有可能一次性传递到服务器端。此时客户端有可能从服务器端收到多个字符串，这不是我们希望看到的结果。还需考虑服务器端的如下情况:

字符串太长，需要分 `2` 个数据包发送。

服务器端希望通过调用 `1` 次 `write` 函数传输数据，但如果数据太大，操作系统就有可能把数据分成多个数据包发送到客户端。另外，在此过程中，客户端有可能在尚未收到全部数据包时就调用 `read` 函数。

所有这些问题都源自 `TCP` 的数据传输特性。那该如何解决呢？

## 第五章: 基于 `TCP` 的服务器端/客户端（`2`）

### 回声客户端的完美实现

```cpp
while (1) {
    cout << "Input message(Q to quit): ";
    fgets(message, BUF_SIZE, stdin);
    // ......
    write(sock, message, strlen(message));
    int str_len = read(sock, message, BUF_SIZE - 1);
    // ......
}
```

回声客户端传输的是字符串，而且是通过调用 `write` 函数一次性发送的。之后还调用一次 `read` 函数，期待着接收自己传输的字符串。这就是问题所在。

既然回声客户端会收到所有字符串数据，过一段时间后再调用 `read` 函数是否可以一次性读取所有字符串数据？的确，过一段时间后即可接收，但需要等多久？

#### 回声客户端问题解决方法

可以提前确定接收数据的大小。若之前传输了 `20` 字节长的字符串，则在接收时循环调用 `read` 函数读取 `20` 个字节即可。

![echo_client2](./src/chapter5/echo_client2.cpp)

#### 如果问题不在于回声客户端: 定义应用层协议

回声客户端可以提前知道接收的数据长度，但更多情况下不太可能。若无法预知接收数据长度时应如何收发数据？此时需要的就是应用层协议的定义。之前的回声服务器端/客户端中定义了如下协议。

**收到Q就立即终止连接。**

同样，收发数据过程中也需要定好协议以表示数据的边界，或提前告知收发数据的大小。服务器端/客户端实现过程中逐步定义的这些规则集合就是应用层协议。

#### 计算器服务器端/客户端示例

下面编写程序。该程序中，服务器端从客户端获得多个数字和运算符信息。服务器端收到数字后对其进行加减乘运算，然后把结果传回客户端。

- 客户端连接到服务器端后以 `1` 字节整数形式传递待算数字个数。
- 客户端向服务器端传递的每个整数型数据占用 `4` 字节。
- 传递整数型数据后接着传递运算符。运算符信息占用 `1` 字节。
- 选择字符 `+`、`-`、`*` 之一传递。
- 服务器端以 `4` 字节整数型向客户端传回运算结果。
- 客户端得到运算结果后终止与服务器端的连接。

[op_server](./src/chapter5/op_server.cpp)

客户端的数据传送格式:

![](./Image/socket/028.png)

[op_client](./src/chapter5/op_client.cpp)

### `TCP` 原理

#### `TCP` 套接字中的 `I/O` 缓冲

如前所述，`TCP` 套接字的数据收发无边界。服务器端即使调用 `1` 次 `write` 函数传输 `40` 字节的数据，客户端也有可能通过 `4` 次 `read` 函数调用每次读取 `10` 字节。


实际上，`write` 函数调用后并非立即传输数据，`read` 函数调用后也并非马上接收数据。更准确地说，`write` 函数调用瞬间，数据将移至输出缓冲；`read` 函数调用瞬间，从输入缓冲读取数据。

![029](./Image/socket/029.png)

如图所示，调用 `write` 函数时，数据将移到输出缓冲，在适当的时候（不管是分别传送还是一次性传送）传向对方的输入缓冲。这时对方将调用 `read` 函数从输入缓冲读取数据。这些 `I/O` 缓冲特性如下:
- `I/O` 缓冲在每个 `TCP` 套接字中单独存在。
- `I/O` 缓冲在创建套接字时自动生成。
- 即使关闭套接字也会继续传递输出缓冲中遗留的数据。
- 关闭套接字将丢失输入缓冲中的数据。

不可能发生超过输入缓冲大小的数据传输。

`TCP` 中有滑动窗口协议，用对话方式呈现如下:
- 套接字 `A`: 你好，最多可以向我传递 `50` 字节。
- 套接字 `B`: `OK`!
- 套接字 `A`: 我腾出了 `20` 字节的空间，最多可以收 `70` 字节。
- 套接字 `B`: `OK`!

数据收发也是如此，因此 `TCP` 中不会因为缓冲溢出而丢失数据。

#### `TCP` 内部工作原理

`TCP` 套接字从创建到消失所经过程分为如下 `3` 步:
- 与对方套接字建立连接。
- 与对方套接字进行数据交换。
- 断开与对方套接字的连接。

[传输层](./%E4%BC%A0%E8%BE%93%E5%B1%82.md)




















